#include "DataDeal.h"

/*************************************************************************
* Function	:  该文件的函数主要用于数据处理，
* Note(s)		:
* Contributor	: 2024年10月1日
**************************************************************************/







INT8U  ReadReceiveCommandChar8(const INT8U* buffer)
{
    return buffer[0];
}

//高位先行
INT16U ReadReceiveCommandInt16(const INT8U* buffer)
{
    return ((INT16U)(buffer[1])<<8) + buffer[0];
}

INT32U ReadReceiveCommandInt24(const INT8U* buffer)
{
    return (buffer[2]<<16) + (buffer[1]<<8) + buffer[0];
}

INT32U ReadReceiveCommandInt32(const INT8U* buffer)
{
    return (buffer[3]<<24) + (buffer[2]<<16) + (buffer[1]<<8) + buffer[0];
}

//低位先行
INT16U ReadReceiveCommandInt16_Low(const INT8U* buffer)
{
    return ((INT16U)(buffer[0])<<8) + buffer[1];
}

INT32U ReadReceiveCommandInt24_Low(const INT8U* buffer)
{
    return (buffer[0]<<16) + (buffer[1]<<8) + buffer[2];
}

INT32U ReadReceiveCommandInt32_Low(const INT8U* buffer)
{
    return (buffer[0]<<24) + (buffer[1]<<16) + (buffer[2]<<8) + buffer[3];
}


////////////////高位先行/////////////////////////
INT16U AddNewCommandByte(INT8U data, INT8U* buffer)
{
    buffer[0] = data;
    return 1;
}

INT16U AddNewCommandInt16(INT16U data, INT8U* buffer)
{
    buffer[0] = (INT8U)(data>>8);
    buffer[1] = (INT8U)data;
    return 2;
}

INT16U AddNewCommandInt24(INT32U data, INT8U* buffer)
{
    buffer[0] = (INT8U)(data>>16);
    buffer[1] = (INT8U)(data>>8);
    buffer[2] = (INT8U)data;
    return 3;
}


INT16U AddNewCommandInt32(INT32U data, INT8U* buffer)
{
    buffer[0] = (INT8U)(data>>24);
    buffer[1] = (INT8U)(data>>16);
    buffer[2] = (INT8U)(data>>8);
    buffer[3] = (INT8U)data;
    return 4;
}

INT16U AddNewCommandBuf(INT8U* mubiao, INT8U* buffer,INT16U len)
{
    memcpy(mubiao,buffer,len);
    return len;
}

//低位先行
INT16U AddNewCommandByte_LOW(INT8U data, INT8U* buffer)
{
    buffer[0] = data;
    return 1;
}

INT16U AddNewCommandInt16_LOW(INT16U data, INT8U* buffer)
{
    buffer[1] = (INT8U)(data>>8);
    buffer[0] = (INT8U)data;
    return 2;
}

INT16U AddNewCommandInt24_LOW(INT32U data, INT8U* buffer)
{
    buffer[2] = (INT8U)(data>>16);
    buffer[1] = (INT8U)(data>>8);
    buffer[0] = (INT8U)data;
    return 3;
}


INT16U AddNewCommandInt32_LOW(INT32U data, INT8U* buffer)
{
    buffer[3] = (INT8U)(data>>24);
    buffer[2] = (INT8U)(data>>16);
    buffer[1] = (INT8U)(data>>8);
    buffer[0] = (INT8U)data;
    return 4;
}





/*************************************************************************
* Function	: Modbus_Crc16
* Description	:  	计算485RTU数据包的CRC校验码
* Input		:		unsigned char *buff：校验数据，在CRC计算时只用8个数据位，起始位及停止位，如有奇偶校验位也包括奇偶校验位，都不参与CRC计算
					unsigned int len：数据长度
* Output		:校验所得的CRC校验码
* Note(s)		:
* Contributor	: 2024年04月19日
**************************************************************************/
unsigned int Modbus_Crc16(unsigned char *buff, unsigned int len)
{
	unsigned int crc = 0xFFFF;
	unsigned int i, j;
	for ( j = 0; j < len; j ++)
	{
		crc = crc ^ buff[j];
		for ( i = 0; i < 8; i++)
		{
			if( ( crc & 0x0001) > 0)
			{
				crc = crc >> 1;
				crc = crc ^ 0xa001;
			}
			else
			{
				crc = crc >> 1;
			}
		}
	}
	return crc;
}
/***********************************************************************************************
* Function		: bcd2todec
* Description	: BCD码转换成bin码   将0x57 转成 57
* Input			:
* Output		:
* Note(s)		:
* Contributor	: 2024年5月19日 14:49:15	wusheng
***********************************************************************************************/
INT8U bcd2todec(INT8U data)						  ///eg: 将0x57 转成 57
{
      INT8U aa;
	  aa = (data & 0xf) + (data>>4)*10 ;
	  return aa ;
}

u32 BCD_to_DEC(u32 Data)
{
	u32 result = 0;
	result = (Data & 0xf) + ((Data>>4)&0xf)*10 + ((Data>>8)&0xf)*100 + ((Data>>12)&0xf)*1000 + ((Data>>16)&0xf)*10000 + ((Data>>20)&0xf)*100000 + ((Data>>24)&0xf)*1000000 + ((Data>>28)&0xf)*10000000;
	return result;
}

/***********************************************************************************************
* Function		: dectobcd(INT16U data16)			 eg:  12 转换成 0x12
* Description	: 2字节 bin码  转换成BCD码
* Input			:
* Output		:
* Note(s)		:
* Contributor	: 2024年5月19日	wusheng
***********************************************************************************************/
INT16U dectobcd(INT16U data16)
{
     INT16U aaa=0;

     if(data16 < 10)
	 {
	      aaa = data16;
	 }
	 else if((data16>=10)&&(data16<100))
	 {
	       aaa = (data16/10)*16 +  data16%10 ;
	 }
	 else if((data16>=100)&&(data16<1000))
	 {
	       aaa = (data16/100)*256 +  (data16%100/10)*16 + data16%10 ;
	 }
	 else if((data16>=1000)&&(data16<10000))
	 {
	       aaa = (data16/1000)*4096 + (data16%1000/100)*256 +  (data16%100/10)*16 + data16%10;
	 }
	 else
	 {}
	 return aaa;
}
u32 Dwin_4CharToINT32U(u8 *buf)
{
	u32 data=0;
	data = (buf[0]<<24) + (buf[1]<<16) + (buf[2]<<8) + buf[3]  ;
	return data;
}
// 123456 转换成 0x12 0x34 0x56
u8 Dwin_INT32UToBcd(u32 data,u8 len,u8 *buf)
{
	u8 a=0,b=0,c=0,d=0,e=0,f=0;
	if(len == 6)
	{
		a = data%1000000/100000 ;
		b = data%100000/10000;
		c = data%10000/1000;
		d = data%1000/100;
		e = data%100/10;
		f = data%10;
		buf[0] = a<<4|b;
		buf[1] = c<<4|d;
		buf[2] = e<<4|f;
	}
	return 0;
}


/*******************和平台通讯的CRC校验***********************/
unsigned char CRCTABH[256]={
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,
0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,
0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,
0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40};

unsigned char CRCTABL[256]={
0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,
0x07,0xC7,0x05,0xC5,0xC4,0x04,0xCC,0x0C,0x0D,0xCD,
0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,
0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,
0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,
0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,
0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,
0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,
0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,
0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,
0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,
0x70,0xB0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,
0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,
0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4B,0x8B,
0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,
0x43,0x83,0x41,0x81,0x80,0x40};

INT16U CRC16_MODBUS_Calc(INT8U *txdat,INT16U len)
{
	INT8U index=0,crch,crcl;
	INT16U returndata=0,i=0;
	crch=0xff;
	crcl=0xff;
	for(i=0;i<len;i++)
	{
		 index=crch^txdat[i];        //txdat[i] 是发送数据
		 crch=crcl^CRCTABH[index];
		 crcl=CRCTABL[index];
	}
	returndata = (crcl*256) + crch ;
	return returndata;
}


static const unsigned int ulTable_CRC32[256] =
{
  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
	0x130476dc, 0x17c56b6b,	0x1a864db2, 0x1e475005,
	0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
	0x4c11db70, 0x48d0c6c7,	0x4593e01e, 0x4152fda9,
	0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
	0x791d4014, 0x7ddc5da3,	0x709f7b7a, 0x745e66cd,
	0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
	0xbe2b5b58, 0xbaea46ef,	0xb7a96036, 0xb3687d81,
	0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
	0xc7361b4c, 0xc3f706fb,	0xceb42022, 0xca753d95,
	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
	0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
	0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
	0x018aeb13, 0x054bf6a4,	0x0808d07d, 0x0cc9cdca,
	0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
	0x5e9f46bf, 0x5a5e5b08,	0x571d7dd1, 0x53dc6066,
	0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
	0xbfa1b04b, 0xbb60adfc,	0xb6238b25, 0xb2e29692,
	0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
	0xe0b41de7, 0xe4750050,	0xe9362689, 0xedf73b3e,
	0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
	0xd5b88683, 0xd1799b34,	0xdc3abded, 0xd8fba05a,
	0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
	0x4f040d56, 0x4bc510e1,	0x46863638, 0x42472b8f,
	0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
	0x36194d42, 0x32d850f5,	0x3f9b762c, 0x3b5a6b9b,
	0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
	0xf12f560e, 0xf5ee4bb9,	0xf8ad6d60, 0xfc6c70d7,
	0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
	0xc423cd6a, 0xc0e2d0dd,	0xcda1f604, 0xc960ebb3,
	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
	0x9b3660c6, 0x9ff77d71,	0x92b45ba8, 0x9675461f,
	0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
	0x4e8ee645, 0x4a4ffbf2,	0x470cdd2b, 0x43cdc09c,
	0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
	0x119b4be9, 0x155a565e,	0x18197087, 0x1cd86d30,
	0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
	0x2497d08d, 0x2056cd3a,	0x2d15ebe3, 0x29d4f654,
	0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
	0xe3a1cbc1, 0xe760d676,	0xea23f0af, 0xeee2ed18,
	0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
	0x9abc8bd5, 0x9e7d9662,	0x933eb0bb, 0x97ffad0c,
	0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
};

/*******************************************************************************
*	描    述	:	CRC32 校验
*	输    入	:	pBuffer			校验数据
					uLen				校验数据长度
*	输    出	:
*	返    回	:
********************************************************************************/
unsigned int AppCRC_crccheck32(unsigned char* pData, unsigned int uLen)
{
	unsigned int i;
	unsigned int crc=0xffffffff;

	for (i=0; i<uLen; i++)
		crc=(crc<< 8)^ulTable_CRC32[((crc>>24)^*pData++)&0xff];
	return crc;
}

/*******************************************************************************
*	描    述	:	连续计算CRC32 校验，
*	输    入	:	pBuffer			校验数据
					uLen				校验数据长度
						oldcrc 上一次的crc值
*	输    出	:
*	返    回	:
********************************************************************************/
unsigned int AppCRC_Continue(unsigned int oldcrc,unsigned char* pData, unsigned int uLen)
{
	unsigned int i;

	for (i=0; i<uLen; i++)
		oldcrc=(oldcrc<< 8)^ulTable_CRC32[((oldcrc>>24)^*pData++)&0xff];
	return oldcrc;
}
/*************app function******************************
名称:unsigned int AppCommon_Str2Int(unsigned char *pBuf, unsigned char Length, unsigned char DecHexFlag)
功能:把字符串转换成int,数的进制由DecHexFlag确定
输入参数:pBuf 数据缓冲区
输出参数:Length 长度
DecHexFlag 10-10进制；16-16进制
返回值:  校验结果
*******************************************************/
unsigned int AppCommon_Str2Int(char *pBuf, unsigned char Length, unsigned char DecHexFlag)
{
	unsigned int Num;
	unsigned char i,j,x;
	Num = 0;
	for(i = 0; i < Length; i++)
	{
		j = pBuf[i];
		if((j >= '0') && (j <= '9'))x = j-'0';
		else if((j >= 'A') && (j <= 'F'))x = j-'A'+0x0A;
		else if((j >= 'a') && (j <= 'f'))x = j-'a'+0x0A;
		else return 0xffff0000;
		Num = Num*DecHexFlag;
		Num += x;
	}
	return Num;
}



unsigned char gabyCRCHi[] =
{ 0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,

0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,
0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,
0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,
0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,
0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,
0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,
0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,
0x80,0x41,0x00,0xc1,0x81,0x40

};

unsigned char gabyCRCLo[] =
{ 0x00,0xc0,0xc1,0x01,0xc3,0x03,0x02,0xc2,0xc6,0x06, 
0x07,0xc7,0x05,0xc5,0xc4,0x04,0xcc,0x0c,0x0d,0xcd, 
0x0f,0xcf,0xce,0x0e,0x0a,0xca,0xcb,0x0b,0xc9,0x09, 
0x08,0xc8,0xd8,0x18,0x19,0xd9,0x1b,0xdb,0xda,0x1a, 
0x1e,0xde,0xdf,0x1f,0xdd,0x1d,0x1c,0xdc,0x14,0xd4, 
0xd5,0x15,0xd7,0x17,0x16,0xd6,0xd2,0x12,0x13,0xd3, 
0x11,0xd1,0xd0,0x10,0xf0,0x30,0x31,0xf1,0x33,0xf3, 
0xf2,0x32,0x36,0xf6,0xf7,0x37,0xf5,0x35,0x34,0xf4, 
0x3c,0xfc,0xfd,0x3d,0xff,0x3f,0x3e,0xfe,0xfa,0x3a, 
0x3b,0xfb,0x39,0xf9,0xf8,0x38,0x28,0xe8,0xe9,0x29, 
0xeb,0x2b,0x2a,0xea,0xee,0x2e,0x2f,0xef,0x2d,0xed, 
0xec,0x2c,0xe4,0x24,0x25,0xe5,0x27,0xe7,0xe6,0x26, 
0x22,0xe2,0xe3,0x23,0xe1,0x21,0x20,0xe0,0xa0,0x60, 
0x61,0xa1,0x63,0xa3,0xa2,0x62,0x66,0xa6,0xa7,0x67, 
0xa5,0x65,0x64,0xa4,0x6c,0xac,0xad,0x6d,0xaf,0x6f, 
0x6e,0xae,0xaa,0x6a,0x6b,0xab,0x69,0xa9,0xa8,0x68, 
0x78,0xb8,0xb9,0x79,0xbb,0x7b,0x7a,0xba,0xbe,0x7e, 
0x7f,0xbf,0x7d,0xbd,0xbc,0x7c,0xb4,0x74,0x75,0xb5, 
0x77,0xb7,0xb6,0x76,0x72,0xb2,0xb3,0x73,0xb1,0x71, 
0x70,0xb0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,
0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9c,0x5c,
0x5d,0x9d,0x5f,0x9f,0x9e,0x5e,0x5a,0x9a,0x9b,0x5b, 
0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4b,0x8b,
0x8a,0x4a,0x4e,0x8e,0x8f,0x4f,0x8d,0x4d,0x4c,0x8c, 
0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,
0x43,0x83,0x41,0x81,0x80,0x40
};


/*******************************************************************************
*	描    述	:	协议使用的CRC校验计算
*	输    入	:	pBuffer			校验数据
					uLen				校验数据长度
						
*	输    出	:	crc值
*	返    回	:
********************************************************************************/
INT16U ModbusCRC(INT8U * pData, INT16U len)
{
	INT8U byCRCHi = 0xff; 
	INT8U byCRCLo = 0xff; 
	INT8U byIdx;
	INT16U crc; 
	while(len--)
	{
		byIdx = byCRCHi ^* pData++;
		byCRCHi = byCRCLo ^ gabyCRCHi[byIdx]; 
		byCRCLo = gabyCRCLo[byIdx];
	}
	crc = byCRCHi; 
	crc <<= 8;
	crc += byCRCLo; 
	return crc;
}



void ReverseVinCode(INT8U * InPut,INT8U *OutPut)
{
	int i = 0;
	for(i=0;i<17;i++)
	{
		OutPut[i] = InPut[16-i];
	}
}




